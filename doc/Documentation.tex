
\documentclass[journal]{IEEEtran}
% *** MISC UTILITY PACKAGES ***
%\usepackage{ifpdf}

% *** CITATION PACKAGES ***
%\usepackage{cite}

% *** GRAPHICS RELATED PACKAGES ***
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  \graphicspath{{PDF/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  \DeclareGraphicsExtensions{.pdf}
\else
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi

% *** MATH PACKAGES ***
%\usepackage{amsmath}
% Note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500

% *** SPECIALIZED LIST PACKAGES ***
%\usepackage{algorithmic}

% *** ALIGNMENT PACKAGES ***
%\usepackage{array}

% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi

% *** FLOAT PACKAGES ***
%\usepackage{fixltx2e}
% Be aware that LaTeX2e kernels dated 2015 and later have fixltx2e.sty's
% corrections already built into the system in which case a warning will
% be issued if an attempt is made to load fixltx2e.sty as it is no longer
% needed.

%\usepackage{stfloats}
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines.

% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
% \usepackage{dblfloatfix}

%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi

% *** PDF, URL AND HYPERLINK PACKAGES ***
%\usepackage{url}
% Basically, \url{my_url_here}.

% correct bad hyphenation here


\begin{document}
\title{StreamGraph Documentation\\ Kommunikations- und Betriebssysteme Projekt Sommersemester 2016}
\author{Florian~Ziesche, Jakob~Karge, and~Boris~Graf}

% The paper headers
\markboth{StreamGraph Documentation}%
{StreamGraph Documentation}

% use for special paper notices%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}
%\IEEEspecialpapernotice{(Invited Paper)}

\maketitle

\begin{abstract}
The abstract goes here.
\end{abstract}


\section{Introduction}
\IEEEPARstart{T}{he} StreamGraph project aims to present the language
simplified in a graphical environment. As such it is intended to be used by
people who have little programming experience or do not wish to engage with the
specifics of the StreamIt language and alleviates the amount of StreamIt
specific semantic knowledge needed. StreamGraph does not contain every construct
or possibility that StreamIt provides since it does not aim to rebuild the
language in a graphical environment.



\subsection{StreamIt Language}
\noindent StreamIt is a language specifically build for applications which
process a continuous stream of data. To achieve good performance on multi-core
or multi-processor machines StreamIt enables highly parallel programming and
programs, while trying to keep the programming as simple as possible.\\

The language features specific basic modules. This documentation focuses on the
StreamGraph project and so only the subset of StreamIt modules which are
realized in StreamGraph today are included and briefly explained. For further
documentation on StreamIt see \cite{streamIt}.\\

The most basic module of the StreamIt language and the only module that
processes data is the filter. A filter, just as any other StreamIt construct,
has exactly one input and exactly one output for data. It consists mainly of a
work and an init function. The init function describes the filter's initial
condition (e.g. initial values of variables). The work function describes the
steps taken in one execution step of the filter and is called every time that
the preconditions are fulfilled.\\

These preconditions are described by the pop, peek and push values. The pop
value describes how many data packages are taken from the input of the filter in
a single execution step of the work function. Similarly the pop value describes
how many data packages are produced in the output of the filter in that
execution step. The peek value describes how far back the filter needs to read
in the input data, i.e. the minimum input queue length, since any value read has
to be processed to by previous filters.


\subsubsection{StreamIt topology}
\label{StreamItTopology}
\noindent Since filters alone do not specify in which order and if they are
connected it is necessary to have language constructs which describe the
connections and the structure of the processing. These constructs will be
referred to as topological construct in the further documentation.\\

One of these constructs is the pipeline. A pipeline connects filters, pipelines
and split-join constructs in a linear fashion. Each pipline has an init function
in which the elements of the pipeline are added and which determines the order
in which a datapacket is processed.\\
\\

The second construct supported by StreamGraph is the split-join construct. This
constucts splits the datapackets of its input to multiple data paths on which
other constructs are placed and joins these paths together at the end of every
path. All in all a split-join construct has exactly one input and one output.\\
\\

\noindent The StreamIt language generates a pipeline based structure. As such
it is not possible to connect two filters or constructs in different pipelines (see Fig.
\ref{fig_StreamIt_topology}.).\\
\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\textwidth]{StreamItTopology}
	\caption{Example for a non permissable connection between pipelines}
	\label{fig_StreamIt_topology}
\end{figure}
\noindent Since split-join constructs have exactly one input and one output and only appear in pairs it is not
 possible to have connections from one split-join pair to another pair(see Fig.
 \ref{fig_StreamIt_topology_between_SJ}) or to have an unequal numbers of splits and joins (see Fig.
 \ref{fig_StreamIt_topology_missing_join}).\\
\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\textwidth]{StreamItTopologyBetweenSJ}
	\caption{Example for a non permissable connection between split-join pairs}
	\label{fig_StreamIt_topology_between_SJ}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\textwidth]{StreamItTopologyMissingJoin}
	\caption{Example for a uneqaul number of splits and joins(inthis case a missing join)}
	\label{fig_StreamIt_topology_missing_join}
\end{figure}
% needed in second column of first page if using \IEEEpubid
%\IEEEpubidadjcol


\section{StreamGraph}
\noindent Here comes the scientific part
\subsection{View}
\noindent The GUI of StreamGraph include tree Parts. On the top there is the menu
bar with the all important functions for the project. At first submenu is like in
other textual editors the File menu with common functions to create new, open, save,
save as or to quit project. In the Edit submenu it is possible to create new Objects.
In the Run submenu the project can be executed. The Debug submenu is only for debuging
the project and is not necessary for the user. \\

% http://search.cpan.org/~hemlock/Gtk2-Ex-MindMapView-0.000001/lib/Gtk2/Ex/MindMapView.pm
The view take up the main part of the GUI window. It is based on the Gtk2::Ex::MindMapView
Perl modul \ref{} and shows the Objects and they connections. The view is designed
minimalistic as a plain surface to have a clear design and a simple usability.
Especially no toolbars or other controll windows were implemented. The graph structure
can be complitly edited with the mouse. A right click open an pop-up menu with the
same entrie as in the Edit submenu. It allows to create an object with two mouse
clicks. The surface can be scrolled with the scrollbars in all four directions.
But it also can be just draged with pressed left muse click. It allows the user
to seperate objects in differt areas. \\

On the buttom of the GUI there is a terminal window, which is used to communicate
with the user. Errors or informations are shown there. \\

\subsubsection{Objects}
Objects wich are shown on the view surface are nodes of the programm graph. There
are four different types: Filter, Parameter, Subgraph and Comment. Each type has
a different geometric form. Connections between the nodes are visualised as lines
with a direction arrow. Connections has also circle pins at the ends. Pins on nodes
with no connection line show that this node has an open input or output. By clicking
on an out pin and draging to another node a new connection can be created. All possible
connections are visulied with bigger pins. If the mouse is over a node with possible
connection, the arrow is glued to the available pin. \\

A connection can simple be marked with maouse over. This is visualised with much
thicker line. A node can be marked with a left mouse click. To mark more than one
node a right mouse click on a node adds the node to the marked naodes. Another intuitive
ways is to draw a select rectangle with a right mouse click on the view surface.
Marked objects can be deleted with DEL key press. \\

\subsection{Property Window}
A double left click on a node opens its property window. It contains all the parameters
from this node. For exaple a filter node has tree tabs: Join, Filter and Split.
In the filter tab the user has the possibility to set the input and output types and
also to edit the filter source code.

\subsection{Model}

\subsubsection{Filter}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.2\textwidth]{FilterBoxGraphic}
  \caption{A node in the StreamGraph}
  \label{fig_filter_node}
\end{figure}
\subsubsection{Paramter}


\subsection{Graph hierarchy}

StreamGraph introduces subgraphs as a new feature for compartmentalization of
code. Subgraphs act like normal filter nodes in the parent graph, but are
actually a pipeline. This makes use of the fact that pipelines and filters can
be used in the same context in StreamIt, namely in other pipelines and in
split-join constructs.


\subsection{GraphCompat}

\noindent The StreamIt topology, as discussed in \ref{StreamItTopology}, is not
only a directed Graph but has additional restrictions. Some of these are not
strictly necessary and some effort was made in StreamGraph to allow for graphs
that are not strictly StreamIt-compatible and then automatically convert them.

This task is taken on by the GraphCompat class. It transforms a given
StreamGraph graph, coming from the user interface, into a new graph which
is compatible with the StreamIt topology.

At the moment it takes care of the following 3 transformations:

\begin{itemize}
\item Sources and Sinks

  A StreamIt graph must start and end with exactly one void-typed input and
  output respectively. StreamGraph also makes the void-typed requirement but
  does not restrict the graph to just one source and one sink. Multiple sources
  and sinks are combined by adding "Void Sources" and "Void Sinks" to the ends
  of the graph when necessary.\\

\item Identities

  StreamIt does not allow direct connections between a split and a join without
  a filter or a pipeline. In StreamGraph such a connection is allowed. In this
  case GraphCompat adds an identity filter instead of the direct connection
  between the split and the join, as can be seen in Fig.
  \ref{fig_split_join_identity}. This filter copies his input to his output
  without changing the content in any way.\\

\item Subgraphs

  Subgraphs as they are, are a feature of StreamGraph, and don't make use of
  StreamIt's joint-compilation features. It essentially does the same though, by
  flattening the graph hierarchy into one single graph.\\

\end{itemize}



\begin{figure*}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{SplitJoinIdentity}
	\caption{Example of adding an identity filter}
	\label{fig_split_join_identity}
\end{figure*}
\noindent The Streamgraph infrastructure allows a graph with multiple sources
and sinks if the sources all have a void input and the sinks all have a void
output type. In that case the GraphCompat class adds a void split/start or
respectively a void join/end to ensure the StreamIt restriction that every
construct has exactly one input and one output, as long as adding these does not
violate the other rules of StreamIt. An example can be viewed in Fig.
\ref{fig_void_end}. The addition of void-starts/splits is handled in an
equivalent manner.\\
\begin{figure*}[h]
	\centering
	\includegraphics[width=\textwidth]{VoidEnd}
	\caption{Example of adding a void-end}
	\label{fig_void_end}
\end{figure*}



\subsection{CodeObject}
\noindent The CodeObject is an interface class which is extended by the Pipeline
class, the SplitJoin class and the Parameter class. It is a general class for
all implemented topological constructs of the StreamIt language. Filters are not
CodeObjects since they do not describe the structure of the graph but rather are
the nodes of the Graph.\\
While Parameters also do not describe the structure of the graph, they may be
needed by multiple CodeObjects and are needed in different configurations while
the code is generated. As such the parameters are an exception to the general
rule that CodeObjects describe the structure of the graph. CodeObjects except
for parameters reference to other CodeObjects or filters. As such a single
CodeObject can have an entire graph ready for code generation stored in a manner
that already has the necessary order and hierarchical structure of a StreamIt
program.\\
Since StreamGraph does not use the concepts of pipelines and split-joines 
but StreamIt expects these constructs the codeObjects rebuild the graph 
with pipeplines and split-joines.
Figure \ref{fig_StreamGraph_To_StreamIt} shows an example of a 
conversion from a simple StreamGraph graph to a CodeObject structure.

\begin{figure*}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{StreamGraphToStreamIt}
	\caption{Example of StreamGraph to StreamIt conversion}
	\label{fig_StreamGraph_To_StreamIt}
\end{figure*}


\subsubsection{Parameter}
\noindent The Parameter class is an approximation of the way parameters are
handled in the StreamIt language. Parameters are an exception in the sense that
they are not topological constructs. In the visible graph they are represented
by nodes. Parameters do not reference other CodeObjects or filters. They only
are referenced from other objects (filters or CodeObjects). Every parameter as a
CodeObject exists exactly once.\\
For better readability in the StreamIt source file the parameters are written as
global variables in the main pipeline and are passed through to the other code
objects.\\


\subsubsection{Pipeline}
\noindent Every StreamIt program contains at least one pipeline, the main
pipeline, in which all other constructs and filters are placed. A pipeline 
CodeObject stores the objects in the order in which a data packet in StreamIt 
will be processed. These objects may be other CodeObjects like split-join 
constructs or filters. If the need for a split-join construct is detected 
while creating the pipeline a split-join construct is created. When the 
creation is complete the pipeline continues its creation and eventually 
returns.\\
Pipelines encompass the maximum possible amount of nodes to minimize the 
amount of needed pipelines. An example of a pipeline can be seen in fig. 
\ref{fig_Pipeline}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\textwidth]{PipelineGraphic}
	\caption{Example of a pipeline}
	\label{fig_Pipeline}
\end{figure}


\subsubsection{SplitJoin}
\noindent Split-join constructs are the most obvious parallel construct in the
StreamIt language. A split-join construct has at least two parallel paths. Every
path in a split-join is modeled as a pipeline. As such when a split-join is
created for every path the creation of a pipeline is started. In StreamIt it is
not necessary to create a pipeline if there is exactly one filter on a path
between a split-join pair. StreamGraph creates a pipeline on every path of a
split-join pair for the sake of convenience. The approach to generate a
pipeline in every case should not increase the execution time significantly and
does not change the order of execution. Because of this reasons it was decided
to not include the feature to only create pipelines in split-join constructs
when strictly necessary.\\
The generation of split-joines is relatively easy as long as the graph is compatible
(for StreamIt compatibility see \ref{StreamItTopology}). As soon as the graph is not 
StreamIt compatible it becomes increasingly difficult to detect and mend. Simple 
mending methods like copying the node of a cross-connection between paths of a 
split-join is only possible if the nodes or filters are stateless. Since 
statelessness and requirements of other mending methods can only be ascertained 
through parsing and checking of the code from the respective constructs and is beyond 
the scope of this project, mending is not included in the current version of StreamGraph.\\
A simple example of a split join is shown in fig. \ref{fig_Split_Join}.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\textwidth]{SplitJoinGraphic}
	\caption{Example of a pipeline}
	\label{fig_Split_Join}
\end{figure}


\subsection{Code generation}
\noindent The code generation as a first step generates the code for every
filter in the graph. This is made possible, because filters are the basic
modules of StreamIt and due to the fact that every meaningful StreamIt program
has at least a Pipeline.  As such StreamIt as a language does not allow programs
consisting only of filters because without a pipeline no connection between
these filters can be made (see \ref{StreamItTopology} for further
explanation).\\
After generating all filters the code generation continues with the main
CodeObject which is a pipeline. While generating the code of a topological
construct (a pipeline or a split-join-pair) it may be necessary to generate the
code of another such topological construct since it is a part of the first
construct. In that case the code generation of the current construct is paused
and the code generation of the contained construct is started. By the time the
code generation of the contained construct is finished the code generation of
the containing construct is continued.\\
The code generation arranges filters and topological constructs according to
their type. Thus a StreamGraph output file first lists all filters, then all
pipelines and last all split-join constructs.\\

\subsection{Improvment and Extension}



\section{Installation and Setup}



\section{Developer documentation}
\noindent In this section you can find in depth documentation to the different
parts of the StreamGraph project.
\subsection{View}



\subsection{Model}



\subsection{GraphCompat}



\subsection{Code generation}

% An example of a floating figure using the graphicx package.
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}

% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
%\begin{figure*}[!t]
%\centering
%\subfloat[Case I]{\includegraphics[width=2.5in]{box}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{box}%
%\label{fig_second_case}}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure*}

% An example of a floating table.
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}

\section{Conclusion}
\noindent The conclusion goes here.

\appendices


% use section* for acknowledgment
\section*{Acknowledgment}


\noindent The authors would like to thank...

\ifCLASSOPTIONcaptionsoff
  \newpage
\fi

\begin{thebibliography}{1}

\bibitem{streamIt}
William~Thies, Michael~Karczmarek, and Saman~Amarasinghe, \emph{StreamIt: A Language for Streaming Applications},\hskip 1em plus
  0.5em minus 0.4em\relax Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, MA 02139.

\end{thebibliography}

% that's all folks
\end{document}
